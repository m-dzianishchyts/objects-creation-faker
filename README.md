# Faker

Необходимо реализовать генератор объектов со случайными тестовыми данными:

```C#
var faker = new Faker();
Foo foo = faker.Create<Foo>();
Bar bar = faker.Create<Bar>();
int i = faker.Create<int>();
// Далее в примерах List носит иллюстративный характер. 
// Вместо него может быть выбрана любая коллекция из условия.
List<Foo> foos = faker.Create<List<Foo>>();
List<List<Foo>> lists = faker.Create<List<List<Foo>>>();
List<int> ints = faker.Create<List<int>>();
```

При создании объекта следует использовать **конструктор**,
а также заполнять **публичные поля и свойства с публичными сеттерами,
которые не были заполнены в конструкторе**. Следует учитывать сценарии,
когда у класса только приватный конструктор, несколько конструкторов,
конструктор с параметрами и публичные поля/свойства.

При наличии нескольких конструкторов следует отдавать предпочтение
конструктору с большим числом параметров, однако если при попытке его
использования возникло исключение, следует пытаться использовать остальные.

Обратите внимание, что у пользовательских типов-значений (value types),
которыми являются структуры, объявляемые ключевым словом ```struct```,
**всегда есть конструктор без параметров**, однако в дополнение к нему может быть
объявлен и пользовательский конструктор (который следует пытаться использовать первым,
руководствуясь логикой предпочтения конструктора с большим числом параметров).

Заполнение должно быть **рекурсивным** (если полем является другой объект,
то он также должен быть создан с помощью `Faker`).

Реализовать генераторы случайных значений для базовых типов-значений
(`int`, `long`, `double`, `float`, etc), строк, одного любого системного класса
для представления определенного типа данных на выбор (дата/время, url, etc),
коллекций объектов всех типов, которые могут быть сгенерированы `Faker`
(поддержка разновидностей `IEnumerable<T>`, `List<T>`, `IList<T>`, `ICollection<T>`,
`T[]` на усмотрение автора, минимум один вариант из приведенных).

Создание коллекций должно выполняться аналогично созданию других типов,
для которых есть генераторы. Внутри кода Faker не должно быть проверок
if/switch на коллекцию и какой-то особой обработки.
Один из вариантов интерфейса IGenerator для такой обработки есть в
[FAQ](https://bsuir.ishimko.me/mpp-dotnet/2-faker/faq#igenerator).
Допустим и любой другой способ, согласующийся с требованием
об отсутствии специальных проверок для коллекций.

Выделить как минимум 2 предопределенных генератора в отдельные
подключаемые модули (плагины), которые будут загружаться на старте приложения.

Предусмотреть учет циклических зависимостей:

```c#
class A
{
    public B { get; set; }
}

class B
{
    public C { get; set; }
}

class C
{
    public A { get; set; } // циклическая зависимость, 
                           // может быть на любом уровне вложенности
}
```

### Работы по курсу
* [Method Execution Tracer](https://github.com/maxiemar/method-execution-tracer)
* [Objects Creation Faker](https://github.com/maxiemar/objects-creation-faker)
* [Assembly Browser](https://github.com/maxiemar/assembly-browser)
* [NUnit Test Generator](https://github.com/maxiemar/nunit-test-generator)
* [Dependency Injection Container](https://github.com/maxiemar/dependency-injection-container)
